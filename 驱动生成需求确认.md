# 设备驱动生成工具需求确认文档

## 项目概述

本项目旨在开发一个**一站式设备驱动生成工具**，为支持 SiLA2 和 gRPC 协议的设备提供标准化的驱动开发解决方案，并通过 JsonRPC 实现 D3 系统与第三方驱动的标准化连接。

## 目标用户

**主要用户**：
- **奔曜售后人员**：使用工具为客户生成和维护设备驱动
- **驱动开发人员**：使用工具进行驱动开发和调试

**潜在用户**：
- **D3 购买者**：待定（根据后续需求确定是否开放给最终用户）

## 核心目标

### 1. 多协议驱动生成支持
- **SiLA2 协议驱动生成**：支持标准化实验室自动化协议
- **gRPC 协议驱动生成**：支持高性能 RPC 通信协议
- **统一接口规范**：为不同协议提供一致的驱动接口

### 2. 标准化通信解决方案
- **JsonRPC 客户端生成**：自动生成标准化的客户端通信代码
- **JsonRPC 服务器端支持**：提供服务器端框架和代码生成
- **D3 系统集成**：解决 D3 与第三方驱动连接的标准化问题

### 3. 智能化配置管理
- **可视化配置界面**：提供用户友好的设备信息配置工具
- **配置文件管理**：支持 CS 配置文件的导入、导出和版本管理
- **动态代码生成**：根据配置实时生成和预览驱动代码

### 4. 多语言原则
所有用户提示部分全部使用英语，注释与日志可以使用中文。

### 5. 双重连接管理
JsonRPC 驱动需要管理两种连接：
- **连接1：RPC 服务器连接**：D3 系统连接到驱动的 JsonRPC 服务器
- **连接2：设备连接**：驱动连接到实际的物理设备

## 详细功能需求

### 数据管理模块

#### 协议特定的数据存储架构

**JsonRPC 协议数据管理**
- **单文件存储**：所有信息存储在一个文件中，包含两个主要章节
  - **章节1：OpenRPC 描述**：完整的 OpenRPC 规范定义，包含方法、参数、返回值等接口信息
  - **章节2：设备配置信息**：设备品牌、型号、设备类型、维护方法、调度方法、通信参数等 JSON 格式数据
- **文件格式**：统一的 JSON 文件，结构化存储所有必要信息
- **特点**：一体化管理，避免文件分离带来的同步问题

**代码特性标注示例**

**C# 特性标注示例**
```csharp
[JsonRpcServer(Host = "0.0.0.0", Port = 8080, DeviceConnectionInfo = "192.168.1.100:502", Description = "设备TCP JsonRPC服务器")]
public class DeviceController
{
    [JsonRpcMethod("ConnectDevice")]
    public override bool ConnectDevice(string info)
    {
        // 连接到物理设备的逻辑
        return true;
    }
    
    public override bool DisconnectDevice()
    {
        // 断开设备连接的逻辑
        return true;
    }
    
    [JsonRpcMethod("Reset")]
    public override bool Reset()
    {
        // 重置设备的逻辑
        return true;
    }
    
    [JsonRpcMethod("EStop")]
    public override bool EStop()
    {
        // 急停的逻辑
        return true;
    }
    
    [JsonRpcMethod("SafeEnter")]
    public override bool SafeEnter()
    {
        // 安全进入检查的逻辑
        return true;
    }
    
    public override bool Prepare()
    {
        // 设备准备的逻辑
        return true;
    }
    
    public override bool GStop()
    {
        // 设备停止的逻辑
        return true;
    }
    
    public override void Dispose()
    {
        // 释放设备资源的逻辑
    }
    
    public override bool PrepareRetry()
    {
        // 设备准备重试的逻辑
        return true;
    }
    
    [JsonRpcMethod("RunProtocol")]
    [MethodOperations] // 调度方法特性
    public bool RunProtocol(string protocolName)
    {
        // 运行协议的逻辑 - 必须是同步方法
        return true;
    }
    
    [JsonRpcMethod("Calibrate")]
    [MethodMaintenance] // 维护方法特性
    public bool Calibrate()
    {
        // 校准设备的逻辑 - 必须是同步方法
        return true;
    }
}
```

@jsonrpc_server(host="0.0.0.0", port=8080, device_connection_info="192.168.1.100:502", description="设备TCP JsonRPC服务器")
class DeviceController:
    
    @jsonrpc_method("ConnectDevice")
    def connect_device(self, info: str) -> bool:
        """连接到物理设备"""
        # 连接到物理设备的逻辑
        return True
    
    @jsonrpc_method("Disconnect")
    def disconnect(self) -> bool:
        """断开设备连接"""
        # 断开设备连接的逻辑
        return True
    
    @jsonrpc_method("Reset")
    def reset(self) -> bool:
        """重置设备"""
        # 重置设备的逻辑
        return True
    
    @jsonrpc_method("EStop")
    def e_stop(self) -> bool:
        """急停"""
        # 急停的逻辑
        return True
    
    @jsonrpc_method("SafeEnter")
    def safe_enter(self) -> bool:
        """安全进入检查"""
        # 安全进入检查的逻辑
        return True
    
    @jsonrpc_method("runTest")
    def run_test(self, config: TestConfig) -> TestResult:
        """运行测试"""
        # 测试执行逻辑
        return TestResult()
```

### JsonRPC 必需方法规范

**强制要求的方法**
所有 JsonRPC 设备驱动必须包含以下方法：

1. **设备连接方法**
   - **方法名**：`bool ConnectDevice(string info)`
   - **功能**：建立与物理设备的连接
   - **参数**：info - 设备连接信息字符串
   - **返回值**：连接成功返回true，失败返回false

2. **设备断开方法**
   - **方法名**：`bool DisconnectDevice()`
   - **功能**：断开与物理设备的连接
   - **返回值**：断开成功返回true，失败返回false

3. **设备连接状态回调属性（强制）**
   - **属性名**：`public Action<bool> DeviceConnectionChanged { get; set; }`
   - **功能**：用于通知D3系统设备连接状态的变化
   - **参数**：true表示设备已连接，false表示设备已断开
   - **触发时机**：在ConnectDevice和DisconnectDevice方法中必须调用此回调
   - **重要说明**：此回调属性不需要在OpenRPC文档中定义，客户端生成工具会自动处理

**条件要求的方法**
如果设备支持以下功能，则必须使用指定的方法名和签名：

4. **设备重置方法**
   - **方法名**：`bool Reset()`
   - **功能**：重置设备到初始状态
   - **返回值**：重置成功返回true，失败返回false

5. **急停方法**
   - **方法名**：`bool EStop()`
   - **功能**：立即停止设备运行
   - **返回值**：急停成功返回true，失败返回false

6. **安全进入方法**
   - **方法名**：`bool SafeEnter()`
   - **功能**：机器人进入前的安全检查和准备动作
   - **返回值**：安全检查通过返回true，失败返回false

7. **设备准备方法**
   - **方法名**：`bool Prepare()`
   - **功能**：设备准备操作
   - **返回值**：准备成功返回true，失败返回false

8. **设备停止方法**
   - **方法名**：`bool GStop()`
   - **功能**：设备停止操作
   - **返回值**：停止成功返回true，失败返回false

9. **设备释放方法**
   - **方法名**：`void Dispose()`
   - **功能**：释放设备资源
   - **返回值**：无返回值

10. **设备准备重试方法**
    - **方法名**：`bool PrepareRetry()`
    - **功能**：设备准备重试操作
    - **返回值**：准备重试成功返回true，失败返回false

### D3 系统调用方法规范

**D3 调用方法同步性要求**
- **强制同步**：所有被 D3 系统调用的方法必须是同步的，不能使用异步调用（async/await）
- **原因**：D3 系统的直接调用机制不支持异步方法调用

**被 D3 调用的方法清单**
以下方法会被 D3 系统直接调用，必须遵循同步性要求：

1. **基础设备方法**：
   - `bool ConnectDevice(string info)`
   - `bool DisconnectDevice()`
   - `bool Reset()`
   - `bool EStop()`
   - `bool SafeEnter()`
   - `bool Prepare()`
   - `bool GStop()`
   - `void Dispose()`
   - `bool PrepareRetry()`

2. **特性标注方法**：
   - 带有 `MethodOperations` 特性的方法（调度方法）
   - 带有 `MethodMaintenance` 特性的方法（维护方法）

**方法重写要求**
当实现以下特定方法时，必须使用 `override` 关键字进行重写：
- `ConnectDevice`
- `DisconnectDevice`
- `Reset`
- `EStop`
- `SafeEnter`
- `Prepare`
- `GStop`
- `Dispose`
- `PrepareRetry`

**方法重载限制**
- **禁止重载**：被 D3 调用的方法不能有重载（即不能存在方法名相同但参数不同的方法）
- **原因**：D3 系统的方法调用机制不支持方法重载的识别和调用
- **验证要求**：代码生成器必须验证被 D3 调用的方法不存在重载情况

**JsonRPC 定义文件示例结构（从代码特性自动生成）**

```json
{
  "openrpc": {
    "openrpc": "1.3.0",
    "info": {
      "title": "设备控制API",
      "version": "1.0.0",
      "description": "设备控制接口规范"
    },
    "servers": [
      {
        "name": "TCP服务器",
        "description": "设备TCP JsonRPC服务器"
      }
    ],
    "methods": [
      {
        "name": "ConnectDevice",
        "description": "建立与物理设备的连接",
        "params": [
          {
            "name": "connectionInfo",
            "schema": {"type": "string"},
            "description": "设备连接信息（IP:Port 或串口路径）",
            "required": true
          }
        ],
        "result": {
          "name": "success",
          "schema": {"type": "boolean"},
          "description": "连接操作是否成功"
        }
      }
    ],
    "components": {
      "schemas": {
        "DeviceStatus": {
          "type": "object",
          "properties": {
            "isConnected": {"type": "boolean", "description": "设备连接状态"},
            "lastError": {"type": "string", "description": "最后错误信息"}
          }
        }
      }
    }
  },
  "driver_metadata": {
    "authorName": "开发者姓名",
    "brand": "设备品牌",
    "model": "设备型号",
    "deviceType": "设备类型",
    "deviceMethods": ["GetStatus", "RunProtocol"],
    "deviceMaintenances": ["Calibrate", "SelfCheck"],
    "rpcServerConnectionInfo": "tcp://0.0.0.0:8080",
    "deviceConnectionInfo": "192.168.1.155:4040"
  }
}
```
**brand,model,deviceType必须使用英文或者下划线或者数字**
 **以下结构简称为OpenRPC驱动描述文件**
   ```json
{
  "openrpc": { ... },           // OpenRPC 1.3.0 规范内容
  "driver_metadata": { ... }    // D3 系统驱动元数据信息
}
```


### 设备驱动描述文件数据模型

根据现有驱动描述文件结构分析，设计的综合数据模型如下：

**综合驱动描述文件数据模型**

```json
{
  "openrpc": {
    "openrpc": "1.3.0",
    "info": {
      "title": "设备控制API",
      "version": "1.0.0",
      "description": "设备控制接口规范"
    },
    "servers": [
      {
        "name": "TCP服务器",
        "description": "设备TCP JsonRPC服务器"
      }
    ],
    "methods": [
      {
        "name": "ConnectDevice",
        "description": "建立与物理设备的连接",
        "params": [
          {
            "name": "connectionInfo",
            "schema": {"type": "string"},
            "description": "设备连接信息（IP:Port 或串口路径）",
            "required": true
          }
        ],
        "result": {
          "name": "success",
          "schema": {"type": "boolean"},
          "description": "连接操作是否成功"
        }
      }
    ],
    "components": {
      "schemas": {
        "DeviceStatus": {
          "type": "object",
          "properties": {
            "isConnected": {"type": "boolean", "description": "设备连接状态"},
            "lastError": {"type": "string", "description": "最后错误信息"}
          }
        }
      }
    }
  },
  "driver_metadata": {
    "authorName": "开发者姓名",
    "brand": "设备品牌",
    "model": "设备型号",
    "deviceType": "设备类型",
    "deviceMethods": ["GetStatus", "RunProtocol"],
    "deviceMaintenances": ["Calibrate", "SelfCheck"],
    "rpcServerConnectionInfo": "tcp://0.0.0.0:8080",
    "deviceConnectionInfo": "192.168.1.155:4040"
  }
}
```
brand,model,deviceType必须使用英文或者下划线或者数字或者这三者的组合

**SiLA2/gRPC 协议数据管理**
- **分层数据存储**：采用分层数据管理策略，将驱动生成过程中的数据分为两个独立层次

**资料1：协议生成代码层**
- **数据来源**：用户导入的 Proto 文件、FDL 文件
- **生成内容**：基础协议代码、gRPC 服务代码、数据契约定义
- **存储位置**：`generated/` 目录下的多个 CS 文件
- **特点**：相对稳定，主要在协议文件变更时重新生成

**资料2：用户配置信息层**
- **数据来源**：用户通过界面填写的设备信息
- **包含内容**：设备品牌、型号、设备类型、维护方法、调度方法、通信参数等
- **存储格式**：JSON 配置文件
- **特点**：经常变更，用户可反复调整和完善

#### 项目文件结构设计

**JsonRPC 项目结构**
```
JsonRPC项目文件夹/
├── device_definition.json       # 单一定义文件
│   ├── openrpc                 # 章节1：OpenRPC 描述
│   └── device_config          # 章节2：设备配置信息
├── templates/                  # 代码模板
│   └── jsonrpc_driver_template.cs
└── output/                     # 最终输出
    ├── jsonrpc_driver.cs       # 生成的 CS 文件
    └── driver.dll              # 编译后的 DLL
```

**SiLA2/gRPC 项目结构**
```
SiLA2项目文件夹/
├── generated/                    # 协议生成文件（资料1）
│   ├── protocol_base.cs         # 基础协议代码
│   ├── grpc_services.cs         # gRPC 服务代码
│   └── data_contracts.cs        # 数据契约定义
├── config/                      # 用户配置文件（资料2）
│   ├── device_info.json         # 设备基础信息
│   ├── method_classification.json # 方法分类配置
│   └── communication_params.json # 通信参数配置
├── templates/                   # 代码模板
│   └── sila2_driver_template.cs # 驱动主体模板
└── output/                      # 最终输出
    ├── sila2_driver.cs          # 合并后的最终 CS 文件
    └── driver.dll               # 编译后的 DLL
```

#### 数据管理功能
- **分层保存**：支持独立保存协议生成结果和用户配置信息
- **增量更新**：支持只更新协议代码或只更新配置信息，无需重新生成全部内容
- **项目管理**：支持整个项目的打包保存、加载和版本管理
- **数据验证**：确保资料1和资料2的兼容性，避免数据不匹配问题
- **进度保存**：用户可以随时保存当前工作进度，下次导入继续编辑

#### 代码生成流程

**JsonRPC 驱动生成流程**
1. **代码特性扫描（强制验证）**：
   - 扫描用户代码中的 JsonRPC 服务器配置特性/装饰器
   - 提取 IP 地址和端口号配置
   - 验证特性/装饰器存在性和参数完整性
   - 验证失败时报错并中断流程，提供代码标注示例
   - 验证通过后自动填充到 OpenRPC servers 字段和驱动描述文件的 deviceCommunications 字段
2. **数据类型验证**：device_definition.json → 数据类型验证器 → 验证通过/失败报告
3. **单文件处理**：验证通过的 device_definition.json（OpenRPC 描述 + 设备配置） → JsonRPC 代码生成器 → 完整的 C# 驱动代码（包含 TCP 服务器）
4. **DLL 编译**：生成的 C# 代码 → 编译器 → DLL 文件（包含自动启动的 TCP JsonRPC 服务器）

**SiLA2/gRPC 驱动生成流程**
1. **协议文件处理**：Proto 文件 + FDL 文件 → 代码生成器 → 资料1
2. **用户配置收集**：用户输入界面 → 配置验证 → 资料2
3. **代码合并生成**：资料1 + 资料2 + 模板 → 代码合并器 → 最终 CS 文件 → DLL 编译

### 配置管理模块

#### 设备基础信息配置
- **设备厂商**：选择或输入设备制造商信息
- **设备型号**：指定具体的设备型号和版本
- **驱动开发人员**：记录开发人员姓名和联系信息
- **仪器类型**：分类管理不同类型的实验设备

#### 方法分类与管理
- **维护方法识别**：标识设备维护相关的操作方法
- **调度方法识别**：标识可被调度系统调用的业务方法
- **方法参数配置**：为每个方法定义输入输出参数

#### 通信参数配置
- **连接参数**：IP 地址、端口等
- **协议特定参数**：针对 SiLA2 和 gRPC 的专用配置
- **JsonRPC 传输层**：第一阶段固定使用 TCP Socket 传输，后期可扩展其他传输方式
- **安全设置**：认证、加密等安全相关配置
- **TCP 服务器配置**：
  - **IP 地址配置**：支持用户输入监听 IP 地址（默认为"0.0.0.0"表示监听所有网卡）
  - **端口配置（代码特性标注）**：
    - **C# 特性标注**：使用自定义特性（Attribute）在代码中标注端口号
    - **Python 装饰器标注**：使用装饰器（Decorator）在 Python 代码中标注端口号
    - **代码扫描验证**：扫描代码中的特性/装饰器，提取端口号配置
    - **必填验证**：如果代码中未找到端口号特性，生成 OpenRPC 时报错并中断流程
    - **错误提示**：提供清晰的错误信息和代码标注示例
  - **配置管理**：
  - 将从代码特性/装饰器中提取的 IP 地址和端口号自动填充到驱动描述文件的 deviceCommunications 字段
  - 作为 OpenRPC servers 字段的数据源
  - 作为 JsonRPC 服务器启动时的默认参数
  - **服务器信息自动填充**：将用户配置的 IP 和端口自动填充到 OpenRPC 的 servers 字段中
  - **配置验证**：验证 IP 地址格式和端口号范围的有效性（1-65535）

### 代码生成模块

#### 配置验证器（JsonRPC 专用）
- **代码特性扫描验证**：
  - **C# 特性扫描**：
    - **扫描逻辑**：扫描代码中的`[JsonRpcServer]`特性，提取端口号配置
    - **特性解析**：解析特性参数，获取 IP 地址和端口号
    - **必填验证**：如果未找到特性或特性中未指定端口号，则报错
  - **Python 装饰器扫描**：
    - **扫描逻辑**：扫描代码中的`@jsonrpc_server`装饰器，提取端口号配置
    - **装饰器解析**：解析装饰器参数，获取 IP 地址和端口号
    - **必填验证**：如果未找到装饰器或装饰器中未指定端口号，则报错
  - **端口号格式验证**：
    - **范围检查**：验证端口号是否在有效范围内（1-65535）
    - **格式检查**：确保端口号为有效的数字格式
    - **占用检查**：检查端口是否被其他程序占用
  - **IP 地址验证**：
    - **格式验证**：验证 IP 地址格式的正确性
    - **可达性检查**：验证 IP 地址是否可用
  - **错误报告机制**：
    - **特性未找到错误**：
      - **错误消息**："未找到 JsonRPC 服务器配置特性，请在代码中添加服务器配置"
      - **C# 解决方案**："请在类或方法上添加 [JsonRpcServer(Host = \"0.0.0.0\", Port = 8080)] 特性"
      - **Python 解决方案**："请在类或函数上添加 @jsonrpc_server(host=\"0.0.0.0\", port=8080) 装饰器"
    - **端口号未指定错误**：
      - **错误消息**："JsonRPC 服务器配置特性中未指定端口号"
      - **解决方案**："请在特性/装饰器中明确指定端口号参数"
      - **示例说明**："有效的端口号范围为1-65535，建议使用8080-8090之间的端口"
    - **中断机制**：配置验证失败时立即中断 OpenRPC 生成流程
- **D3调用方法验证**：
  - **同步性验证**：
    - **检查逻辑**：扫描被D3调用的方法，确保它们不使用async/await关键字
    - **验证范围**：包括基础设备方法和带有MethodOperations/MethodMaintenance特性的方法
    - **错误报告**：提供具体的异步方法位置和修改建议
  - **Override关键字验证**：
    - **验证方法**：ConnectDevice、DisconnectDevice、Reset、EStop、SafeEnter、Prepare、GStop、Dispose、PrepareRetry
    - **检查逻辑**：确保这些方法使用override关键字进行重写
    - **错误提示**：提供缺少override关键字的方法列表和修改示例
  - **方法重载验证**：
    - **检查逻辑**：验证被D3调用的方法不存在重载（方法名相同但参数不同）
    - **验证范围**：所有基础设备方法和带有特性标注的方法
    - **错误报告**：列出存在重载的方法名和具体的重载签名
  - **特性标注方法验证**：
    - **扫描MethodOperations特性**：识别调度方法并验证其同步性
    - **扫描MethodMaintenance特性**：识别维护方法并验证其同步性
    - **特性存在性验证**：确保特性正确标注在方法上
  - **错误处理机制**：
    - **详细错误信息**：提供具体的方法名、行号和错误类型
    - **修改建议**：提供具体的代码修改示例
    - **中断流程**：发现D3调用方法不符合要求时立即中断生成流程

#### 数据类型验证器（JsonRPC 专用）
- **支持的数据类型定义**：
  - **入参类型**：int, byte, sbyte, string, DateTime, double, float, Byte[], Enum,bool
  - **返回值类型**：int, bool, byte, sbyte, string, DateTime, double, float, Enum
  - **复合类型**：只包含基础类型的class、struct（不允许嵌套）
- **验证功能**：
  - **方法签名扫描**：解析 OpenRPC 描述中的所有方法定义
  - **参数类型检查**：逐一验证每个方法的入参类型是否在支持范围内
  - **返回值类型检查**：验证每个方法的返回值类型是否在支持范围内
  - **复合类型深度检查**：对 class、struct 类型进行成员类型递归验证，确保不存在嵌套或不支持的类型
- **错误报告**：
  - **精确定位**：报告具体的类名、方法名、参数名或返回值
  - **详细描述**：说明不支持的具体数据类型和原因
  - **中断机制**：发现不支持的类型时立即中断生成流程
- **模块化设计**：
  - **类型定义配置化**：支持的数据类型通过配置文件定义，便于扩展
  - **验证规则可扩展**：验证逻辑采用策略模式，便于添加新的验证规则
  - **插件式架构**：支持通过插件方式添加新的数据类型支持

#### CS 文件生成与管理
- **自动代码生成**：根据配置自动生成完整的 C# 驱动代码
- **实时预览功能**：配置更改时实时显示生成的代码
- **手动调整支持**：允许用户对生成的代码进行微调
- **代码验证**：确保生成的代码符合编译要求

#### 协议特定的文件管理

**JsonRPC 文件管理**
- **单文件导入**：支持导入包含 OpenRPC 描述和设备配置的完整定义文件
- **一体化编辑**：在同一界面中编辑 OpenRPC 规范和设备配置信息
- **模板管理**：提供常用 JsonRPC 设备的定义文件模板

**SiLA2/gRPC 文件管理**
- **协议文件导入**：支持导入 Proto 文件、FDL 文件，生成资料1（协议代码层）
- **项目文件保存**：将整个项目（资料1+资料2）保存为项目包，便于分享和备份
- **项目文件导入**：支持导入之前保存的项目包，完整恢复工作状态
- **增量导入**：支持只导入协议文件或只导入配置文件，实现灵活的项目管理
- **版本控制**：分别追踪协议代码层和配置信息层的版本变化
- **模板管理**：提供常用设备类型的配置模板和代码模板

### 测试与调试模块

#### 设备连接测试
- **连接状态检测**：验证设备连接的可用性（基于 TCP Socket 的 JsonRPC 通信）
- **通信测试**：发送测试命令并验证响应

#### DLL 编译与生成
- **自动编译**：将生成的 C# 代码编译为 DLL 文件
- **输出管理**：组织编译输出文件的目录结构

### TCP JsonRPC 服务器模块

#### 自动附加启动的 TCP 服务器
- **服务器自动启动**：
  - 驱动 DLL 加载时自动启动内置的 TCP JsonRPC 服务器
  - 使用用户配置的 IP 地址和端口号启动监听
  - 支持多线程处理并发连接请求
- **服务器生命周期管理**：
  - **启动管理**：驱动初始化时自动启动服务器
  - **停止管理**：驱动卸载时自动停止服务器并释放资源
  - **重启管理**：支持服务器配置变更时的热重启
- **连接管理**：
  - **客户端连接处理**：支持多个客户端同时连接
  - **连接状态监控**：实时监控客户端连接状态
  - **连接超时处理**：自动清理超时的连接
- **请求处理**：
  - **JsonRPC 协议解析**：完整支持 JsonRPC 2.0 协议规范
  - **方法调用路由**：将 JsonRPC 请求路由到对应的设备方法
  - **异常处理**：统一处理方法调用异常并返回标准错误响应
  - **并发控制**：支持并发请求处理，确保设备操作的线程安全
- **日志与监控**：
  - **请求日志**：记录所有 JsonRPC 请求和响应
  - **错误日志**：记录服务器运行过程中的错误信息
  - **性能监控**：监控服务器性能指标（连接数、请求处理时间等）
- **配置管理**：
  - **配置自动集成**：
    - 从代码特性/装饰器中提取的 IP 地址和端口号自动集成到驱动描述文件
    - 确保配置的一致性和准确性

### 打包发布模块

#### 驱动描述文件生成
- **注释提取与补充**：从生成的 DLL 中提取方法注释，并通过 FDL 文件或 JsonRPC 文件自动补充调度方法和维护方法的注释
- **方法分类标注**：在描述文件中明确标注哪些是调度方法，哪些是维护方法
- **元数据生成**：基于 DLL 注释和配置信息生成完整的驱动描述文件
- **描述文件验证**：确保生成的描述文件包含完整的方法说明和分类信息
- **注释完整性检查与补充**：
  - **必需的注释信息**：
    - 方法描述（method description）
    - 入参描述（parameter description）
    - 返回值描述（return value description）
    - 返回值为class/struct时的字段/属性描述
    - 入参为枚举时的枚举项描述
  - **缺失注释警告机制**：
    - 扫描 OpenRPC 描述文件中的 description 字段
    - 对缺失的注释信息生成详细警告报告
    - 警告信息包含具体的方法名、参数名、字段名等定位信息
  - **缺省值填充策略**：
    - **方法注释缺失**：使用方法名称作为缺省描述
    - **入参注释缺失**：使用入参名称作为缺省描述
    - **返回值注释缺失**：使用空字符串("")作为缺省描述
    - **class/struct 字段注释缺失**：使用字段名称作为缺省描述
    - **枚举项注释缺失**：使用枚举项名称作为缺省描述
  - **OpenRPC 描述字段映射**：
    - 将所有注释信息统一存储在 OpenRPC 规范的 description 字段中
    - 建立 description 字段与不同注释类型的映射关系
    - 支持从 description 字段中提取和重构完整的注释信息

#### 安装包制作
- **集成现有工具**：利用现有的安装包制作工具完成驱动打包
- **文件组织**：将 DLL、描述文件等按要求组织到安装包中

## 技术实现要求

### 开发环境与工具链
- **.NET 8.0**：使用 .NET 8.0 进行开发

### 代码特性与装饰器实现

#### C# 特性（Attribute）实现
- **JsonRpcServerAttribute**：
  ```csharp
  [AttributeUsage(AttributeTargets.Class ]
  public class JsonRpcServerAttribute : Attribute
  {
      public string Host { get; set; } = "0.0.0.0";
      public int Port { get; set; }
      public string Description { get; set; } = "";
     public string DeviceConnectionInfo { get; set; } 
  }
  ```
- **JsonRpcMethodAttribute**：
  ```csharp
  [AttributeUsage(AttributeTargets.Method)]
  public class JsonRpcMethodAttribute : Attribute
  {
      public string MethodName { get; set; }
      public string Description { get; set; } = "";
      
      public JsonRpcMethodAttribute(string methodName)
      {
          MethodName = methodName;
      }
  }
  ```

#### 代码扫描与解析
- **C# 反射解析**：使用 .NET 反射机制扫描程序集中的特性
- **Python AST 解析**：使用 Python 的 ast 模块解析源代码中的装饰器
- **跨语言支持**：支持在同一个项目中混合使用 C# 和 Python 代码

## 项目里程碑

### 第一阶段：JsonRPC 客户端代码生成与基础设施
- **目标**：建立 JsonRPC 驱动生成的核心基础设施，实现根据 OpenRPC 驱动描述文档生成客户端代码并作简单校验
- **功能范围**：
  - **TCP JsonRPC 数据帧定义与核心模块迁移实现**：
    - 定义 TCP JsonRPC 通信协议的数据帧格式：`[length: 4 bytes big endian][binary message content]`
    - content 采用 UTF-8 编码
    - 实现数据帧的编码和解码功能
    - 迁移现有核心模块到新的数据帧格式
  - **根据 OpenRPC 驱动描述文档生成 JsonRPC 客户端代码**：
    - 基于 OpenRPC 规范自动生成 JsonRPC 客户端代码
    - 生成完整的客户端项目结构
    - 实现项目自动编译功能
    - 根据编译后的注释文档和 DLL 生成驱动描述文件
  - **基础校验功能**：
    - 实现 OpenRPC 文档格式的基础校验
    - 验证必需字段的存在性和有效性
    - 检查方法定义的完整性
    - 提供校验结果报告和错误提示
  - **数据模型文档编写**：
    - 编写综合驱动描述文件数据模型的详细文档
    - 说明 JSON 序列化后每个字段的作用和参考示例
    - 提供字段验证规则和约束条件
  - **TCP JsonRPC 数据帧规范文档编写**：
    - 编写 TCP JsonRPC 数据帧定义的技术规范文档
    - 详细说明数据帧格式：`[length: 4 bytes big endian][binary message content]`
    - 说明 content 的 UTF-8 编码要求
    - 提供数据帧处理的实现示例
- **交付成果**：可运行的控制台程序，支持根据 OpenRPC 驱动描述文档生成 JsonRPC 客户端代码，并提供基础校验功能

### 第二阶段：JsonRPC 完整驱动生成流程
- **目标**：实现JsonRPC协议的完整驱动生成流程，使用控制台交互
- **功能范围**：
  - 实现OpenRPC规范文件解析功能
  - **实现配置验证器**：
    - 实现代码特性/装饰器扫描功能
    - 实现端口号和设备连接信息必填验证和错误报告机制
    - 实现端口号格式和范围验证
    - 验证必需方法（ConnectDevice、DisconnectDevice）的存在性
    - 验证条件方法（Reset、EStop、SafeEnter、Prepare、GStop、Dispose、PrepareRetry）的方法签名
    - **验证D3调用方法的同步性要求**：
      - 检查被D3调用的方法是否为同步方法（不能使用async/await）
      - 验证特定方法是否使用了override关键字
      - 检查被D3调用的方法是否存在重载（禁止重载）
      - 验证带有MethodOperations和MethodMaintenance特性的方法的同步性
    - 提供清晰的错误信息和代码标注示例
    - 验证失败时中断生成流程
  - **实现数据类型验证器**：
    - 支持指定的基础数据类型验证
    - 支持复合类型（class、struct）的成员类型验证
    - 提供详细的错误报告和精确定位
    - 采用模块化设计，便于后续扩展
  - 实现单文件数据管理（OpenRPC描述 + 设备配置）
  - 通过控制台交互收集和编辑设备配置信息
  - 实现JsonRPC驱动代码生成功能
  - **实现TCP JsonRPC服务器自动附加功能**：
    - 生成包含自动启动TCP服务器的驱动代码
    - 实现服务器生命周期管理
    - 实现JsonRPC请求路由和处理
    - 实现并发控制和异常处理
    - **实现配置持久化和动态修改功能**：
      - 生成配置文件读写代码
      - 实现运行时配置修改API
      - 实现配置变更时的服务器重启逻辑
  - 实现双重连接测试功能：
    - 基于TCP Socket的JsonRPC通信测试（连接1）
    - 设备物理连接测试（连接2）
  - 实现DLL编译功能
  - **实现注释完整性检查和驱动描述文件生成功能**：
    - 实现注释缺失检查和警告机制
    - 实现缺省值填充策略
    - 支持OpenRPC描述字段的完整映射
    - 支持复合类型和枚举类型的详细注释处理
    - 生成符合新数据模型的驱动描述文件
  - 集成现有安装包制作工具
- **交付成果**：可运行的控制台程序，支持JsonRPC协议的完整驱动生成流程

### 第三阶段：SiLA2/gRPC 协议实现（控制台版本）
- **目标**：实现 SiLA2 和 gRPC 协议的完整驱动生成流程，使用控制台交互
- **功能范围**：
  - 实现 Proto 文件、FDL 文件解析功能
  - 实现资料1生成：基于协议文件自动生成 C# 协议代码
  - 实现资料2收集：通过控制台交互收集用户配置信息（设备厂商、型号、方法分类等）
  - 实现分层数据存储：协议代码层与配置信息层分离保存
  - 实现代码合并功能：将资料1和资料2合并生成最终的 C# 驱动文件
  - 实现基础的设备连接测试功能
  - 实现 DLL 编译功能
  - 实现注释自动补充和驱动描述文件生成功能
  - 集成现有安装包制作工具
- **交付成果**：可运行的控制台程序，支持 SiLA2/gRPC 协议的完整驱动生成流程

### 第四阶段：用户界面与功能完善
- **目标**：开发用户友好的界面，完善各项功能，整合两种协议的支持
- **功能范围**：
  - 开发统一的可视化配置界面，支持 JsonRPC 和 SiLA2/gRPC 两种协议选择
  - 实现 JsonRPC 单文件管理的可视化界面
  - 实现 SiLA2/gRPC 分层数据的可视化管理界面
  - 实现 C# 代码的实时预览和编辑功能
  - 完善设备连接测试界面（支持两种协议）
  - 实现项目文件的完整导入导出功能
  - 完善安装包制作功能
  - 添加错误处理和用户提示
  - 优化用户体验，适配奔曜售后人员和驱动开发人员的使用习惯
- **交付成果**：完整的桌面应用程序，支持 JsonRPC 和 SiLA2/gRPC 两种协议的驱动生成

## 风险评估与缓解策略

### 技术风险

#### 1. SiLA2 协议复杂性
- **风险描述**：SiLA2 协议标准复杂，涉及 gRPC、Protocol Buffers 等多种技术栈
- **影响程度**：高 - 可能导致驱动生成的代码无法正确与 SiLA2 设备通信
- **缓解策略**：
  - 采用推荐的固定版本 SiLA2 SDK，避免版本兼容性问题
  - 优先实现基础功能，逐步扩展高级特性
  - 建立完整的测试用例覆盖常见的 SiLA2 通信场景

#### 2. gRPC 代码生成困难
- **风险描述**：gRPC 的 .proto 文件解析和 C# 代码自动生成存在技术挑战
- **影响程度**：中 - 可能影响 gRPC 协议驱动的生成质量
- **缓解策略**：
  - 使用成熟的 gRPC 工具链进行代码生成
  - 建立标准化的 .proto 文件模板
  - 实现 .proto 文件的语法验证和错误提示

#### 3. C# 代码质量控制
- **风险描述**：自动生成的 C# 代码可能存在语法错误、编译问题或运行时异常
- **影响程度**：高 - 直接影响生成驱动的可用性
- **缓解策略**：
  - 实现代码生成模板的语法检查
  - 集成 C# 编译器进行实时编译验证
  - 建立代码质量评估工具
  - 提供代码预览和手动调整功能

#### 4. DLL 编译环境依赖
- **风险描述**：用户机器可能缺少必要的编译环境或 .NET 运行时
- **影响程度**：中 - 可能导致 DLL 编译失败
- **缓解策略**：
  - 检测用户环境的 .NET 版本和编译工具
  - 提供环境检查和安装指导
  - 考虑提供在线编译服务作为备选方案

#### 5. 配置验证风险（JsonRPC 专用）
- **风险描述**：用户可能忘记在代码中添加服务器配置特性/装饰器，或者配置参数无效，导致生成流程失败或服务器无法启动
- **影响程度**：高 - 直接影响驱动生成和服务器启动
- **缓解策略**：
  - **强制验证机制**：在生成 OpenRPC 前强制验证代码中是否存在服务器配置特性/装饰器
  - **清晰的错误提示**：提供具体的错误信息和代码标注示例
  - **多语言支持**：提供 C# 特性和 Python 装饰器的标注示例
  - **代码模板**：提供预设的代码模板，减少用户配置错误
  - **IDE 集成**：考虑提供 IDE 插件或代码片段，简化特性标注过程

#### 6. TCP 服务器运行风险
- **风险描述**：TCP JsonRPC 服务器可能因为端口占用、网络配置、防火墙等原因无法正常启动或运行
- **影响程度**：高 - 直接影响驱动的通信功能
- **缓解策略**：
  - **端口可用性检查**：启动前检查端口是否被占用，提供端口冲突解决方案
  - **网络配置验证**：验证 IP 地址的有效性和网络接口的可用性
  - **防火墙检测**：检测防火墙规则，提供配置指导
  - **服务器健康检查**：定期检查服务器运行状态，自动重启失败的服务器
  - **备用端口机制**：支持配置多个备用端口，自动切换到可用端口
  - **详细错误日志**：记录服务器启动和运行过程中的详细错误信息

#### 7. 数据持久化和恢复
- **风险描述**：分层数据文件的导入解析可能失败，无法正确恢复项目状态
- **影响程度**：中 - 影响用户的工作连续性
- **缓解策略**：
  - 设计健壮的项目文件解析算法
  - 实现分层数据的独立验证机制
  - 提供数据恢复失败时的手动修复工具
  - 建立数据完整性检查机制

#### 8. 分层数据同步风险（仅适用于 SiLA2/gRPC）
- **风险描述**：在 SiLA2/gRPC 协议中，资料1（协议代码）和资料2（用户配置）之间可能出现不同步或不兼容的情况
- **影响程度**：高 - 可能导致最终合并的代码无法正常工作
- **缓解策略**：
  - 建立严格的数据兼容性检查机制
  - 实现版本标记和依赖关系追踪
  - 提供数据同步冲突的检测和解决工具
  - 在代码合并前进行完整性验证
- **注意**：JsonRPC 协议采用单文件管理，不存在此风险

#### 9. 注释补充和描述文件生成风险
- **风险描述**：从 FDL 文件或 JsonRPC 文件自动补充方法注释时可能出现解析错误或注释不匹配，注释完整性检查可能存在漏检或误报
- **影响程度**：中 - 影响驱动描述文件的完整性和准确性
- **缓解策略**：
  - 建立健壮的文件解析机制，支持多种格式的 FDL 和 JsonRPC 文件
  - 实现注释匹配的验证算法，确保注释与方法的对应关系正确
  - **建立多层次的注释完整性检查**：
    - 实现 OpenRPC 描述字段的语法验证
    - 建立注释缺失检查的完整测试用例
    - 提供详细的警告日志和缺省值填充记录
  - 提供手动注释编辑功能，允许用户补充或修正自动生成的注释
  - 建立注释模板库，为常见方法类型提供标准注释模板
  - **实现注释质量评估机制**：
    - 统计注释完整度（有多少使用了缺省值）
    - 提供注释质量报告，帮助用户改进注释内容

#### 10. 数据类型验证风险（JsonRPC 专用）
- **风险描述**：数据类型验证器可能存在漏检或误报，导致不支持的类型通过验证或支持的类型被错误拒绝
- **影响程度**：高 - 直接影响驱动生成的成功率和质量
- **缓解策略**：
  - 建立完整的测试用例覆盖所有支持和不支持的数据类型
  - 实现多层验证机制，包括语法验证和语义验证
  - 提供验证结果的详细日志，便于问题排查
  - 建立类型验证的回归测试，确保扩展时不影响现有功能

#### 11. 第三方库依赖风险
- **风险描述**：依赖的 SiLA2 SDK、gRPC 库等可能存在 bug 或安全漏洞
- **影响程度**：中 - 可能影响生成驱动的稳定性和安全性
- **缓解策略**：
  - 选择稳定版本的第三方库
  - 建立依赖库的版本管理机制
  - 定期评估和更新依赖库版本

## SiLA2 协议数据类型支持的疑问

**待讨论问题**：
- SiLA2 协议是否也需要类似 JsonRPC 的数据类型限制？
- 如果需要，支持的数据类型范围是什么？
- gRPC 的 Protocol Buffers 类型系统与 JsonRPC 类型系统的映射关系如何处理？
- 是否需要为 SiLA2 协议单独设计数据类型验证器？

**暂定处理方案**：
- 第一阶段和第二阶段暂不对 SiLA2 协议实施数据类型限制
- 在第四阶段用户界面开发时，根据实际需求再确定 SiLA2 的数据类型支持策略
- 保持验证器的模块化设计，便于后续为 SiLA2 协议添加类似的验证机制

